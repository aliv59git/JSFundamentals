25.05.2015 г.


Лекция 3 

JS1 Fundamentals  Условни конструкции

Лектор - Евлоги

Разлики при switch.  

При if като условия може много различни неща да се поставят. ({}) дори обект може да постави.

if(!(+str)){
 Exception  -> throw new .....
}

В условните констр,кции използва, че true -> 1 false -> 0;     т.е.  if(numb %2)   if(+str)....  if(n)   if(!n)   if(n%2)... и други подобни комбинации. 

Може да има нестване на if - конструкцията. 

i+=1   е по-добре в цикъла да се пише отколкото i++  

switch(day){
 На пръв поглед всичко е еднакво. ->   както при c#
 но има различия!
}
Задължително на всеки ред да се поставя break;  !!!  иначе има странно поведение. 

Тук в кейсовете могат да се използват изрази (не само константни неща, както в C#). 

truthy    falsy

if( променлива) {console.log(' ')} 

Продължение на лекцията  Важно!

Показва как да си направим полета за инпут и конзола

Продължава със следващата лекция 

Loop

Променливите да се дефинират в началото на функцията,  В цикъла индексатора остава и след това. т.е. той е в скоупа на функцията и не завършва с цикъла. 

while()   do...while()   for(var i=0; i<10; i+=1)

for-in  цикъл - Обхожда пропертитата на някакъв обект, който му подадем. Може да се обходят и повече обекти.

Много интересен начин за обикаляне на елементите на document

Новия фор-цикъл в JS е по-близък до foreach  

for-of 

Работи само за масиви. В новия стандарт го има. Миналата година го е нямало. 



Конфигуриране на WebStorm за работа с node.js

http://blog.jetbrains.com/webstorm/2014/01/getting-started-with-node-js-in-webstorm/

прикачен файл с експортни сетинги за WebStorm.


ЗА ИЗПИТА

Здравейте колеги, 
Изпитът идва и аз лично решавам задачите по няколко пъти. И си изкарвам нещата, които ще са ми полезни за него:
1. Да си направя три .js файла със следните templates:
function solve(input) {
    var len = input.length;
}
var test1 = [];
var test2 = [];
console.log(solve(test1));
console.log('-------------------------') // за да са ми отделени решенията на два теста 
console.log(solve(test2));
2. При задачите със стрингове е хубаво да се прави trim() колкото е възможно по-често или още в началото един цял replace на всички multiwhite-spaces с един:
string = string.replace(/  +/g, ' ');
3. Превръщане на стрингово число в number число: '21' * 1 = 21;
4. Да се внимава, ако в задачата има няколко for цикъла, да се използва i, j , k, m... да не се използва повторно i примерно, че може да стане мазало от горния for цикъл :)
5. Да се внимава и със търсенето на мин и макс. На първоначалните стойности да се присвояват +Infinity и -Infinity, че MIN_VALUE и MAX_VALUE не са типичните мин и макс валюта :) (виж. лекциите).
6. При обхождане на матрица, и ако се опитаме да вземем matrix[i+1][j+1], ако i+1 не съществъва (i + 1 === undefined), то ще гръмне, и аз лично съм се чудил 5 часа защо гърми :) изводът е първо да се провери дали i+1 съществува :)
7. Да се избягват Math... blah blah blah.. че са много бавни и може bgcoder да гръмне за време. Има си алтернативи. Math.floor == 22.3 | 1 (22). Math.pow == един for цикъл.
8. При стринговите задачи да се ползва автомат (символ по символ да се гледа и да се правят 15 хиляди if). (Задачите със стрингове могат и да се решават с парсване, но може да стане голямо мазало там) (Надявам се трейнърите да се смилят и да дадат малко по-не толкова завъртяни задачи, и да могат да се решават на части, примерно).
9. И може би най-важното за мен: да се проверява почти всеки ред дали ти изкарва това, което ти искаш, чрез проверяване с различни примери. Step by step :)
10. <good></luck>
п.п. ако някой иска и се сети нещо друго да сподели :)

 Да добавя нещо с което може да се поблъскате много - array.sort() не сортира числа като числа, а като стрингове.
За това :
  array.sort(function(a, b) {return a - b});

Ще добавя и следните:
- да си направим една функция за проверка на числа : 
function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
- пълнене на двумерен масив(матрица) :
var matrix = [], rows = 5, cols = 5 ,row , col , count ;
for(row = 0; row < rows; row += 1) {
     matrix.push( [] );
      for ( col = 0; col < cols; col += 1){
           matrix[row][col] = count;
           count += 1;
     }
}
- ако искаме да копираме масив и новия да не е с референция към стария ,а да е изцяло нов:
var numbers = [5, 6, 7, 8, 9];
var copy = numbers.slice();
numbers[1] = 100;
console.log(numbers); // [5,100,7,8,9];
console.log(copy); // [5,6,7,8,9];
		































